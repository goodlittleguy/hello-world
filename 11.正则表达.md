



## 正则表达



###### 1.基本语法



我们现在简单地介绍一下语法

>   -   `\d` 匹配数字
>   -   `\w ` 匹配字母或数字
>   -   `.` 匹配任意字符
>   -   `\s` 匹配一个空格



现在我们来看看进阶:

>   -   在匹配语法后加 `{3,8}` 表示匹配 3 到 8 次
>   -   后加 `*` 表示匹配任意次
>   -   后加 `+` 匹配正整数次
>   -   后加 `?` 表示匹配 0 次到 1 次
>   -   用括号将语法们包括表示执行其中一个 ,例: r`[0-9a-zA-Z\_]+` 表示匹配至少由一个数字、字母或者下划线组成的字符串 
>   -   `A|B` 表示匹配 A 或 B
>   -    `^`表示行的开头
>   -     `$`表示行的结束 

在这里我们建议全部匹配字符前加上 `r` 这样就不用考虑转义的问题了



###### 2.使用`re` 切分字符串

代码如下:

```python
'''传统方法'''
>>> 'a b   c'.split(' ')
['a', 'b', '', '', 'c'] #无法识别连续空格

'''现在我们使用`re`试试'''
>>> re.split(r'[\s\,\;]+', 'a,b;; c  d')
['a', 'b', 'c', 'd'] #只要你出现了一次或无限次 空格 或 , 或 ; 我们都能准确有效地切分字符串
```



###### 3.利用`()`  分组

举例如下,当我们想要提取出

-   <Tom Paris> tom@voyager.org 里的 Tom Paris

-   bob@example.com 里的 bob

```python
import re
'''当我们不用分组时'''
def name_of_email(addr):
	m = re.match(r'\<?[a-zA-z]*\s*[a-zA-z]*\>?',addr).group(0)
    if m[0] == '<' and m[-1] == '>':
        m = m[1:-1]
    return m

'''当我们使用分组时'''
	m = re.match(r'(\<?)([a-zA-z]*\s*[a-zA-z]*)(\>?)',addr).group(2) #其中 `group(0)' 表示全部被匹配的字符串, `group(1)` 表示第一个()所匹配的字符串,以此类推
    return m; 
```



###### 3.贪婪匹配

在默认情况下 `re` 默认匹配尽可能多的字符串 , 当我们希望匹配少的字符串时,我们可以在后面加上 `?` 

举例如下:

```python
'''不使用`?`时'''
>>> re.match(r'^(\d+)(0*)$', '102300').groups()
('102300', '') #可以看出来后面的(0*)什么都没匹配上 

'''现在我们来看看 `?` 的作用'''
>>>>>> re.match(r'^(\d+?)(0*)$', '102300').groups()
('1023', '00') 
```



###### 4.正则预编译

当我们在Python中使用正则表达式时，re模块内部会干两件事情：

>   1.  编译正则表达式，如果正则表达式的字符串本身不合法，会报错；
>   2.  用编译后的正则表达式去匹配字符串。

当我们可能使用一个正则表达式许多次时,我们可以选择预编译该正则表达式

```python
import re
>>>telephone = re.compile(r'(^\d{3})-(\d{3,8}$)')
>>>telephone.match('010-12345').groups()
('010','12345') #注意这里没有被括号包含的 `-` 没有纳入 groups 的考虑范围 , 同理 group(2)也无法表示 `-` ,要想将 `-` 表示出来可以换用 group(0)
```

