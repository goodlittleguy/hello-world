## 指针









### 指针究竟什么



>   指针说白了就是一个内含一个变量的地址的变量
>
>   这样就决定了指针也有它的指针和它的指针和......



>   指针,同时也是一个只包含一个元素的列表,这就决定了,你不仅仅可以使用 *p 来代表一个变量,你还能用 p[0] 来代表这个变量

我们来验证一下我们的看法:

```c
>>>int a = 2, *p = &a;
>>>printf(*p);
>>>2;
>>>printf(p[0]);
>>>2;
```



需要重申一下,**指针仅仅是拥有一个元素的列表** 

现在我们针对这个专门举一个例子:

```c
#我们看看指针和列表是不是完全相同

#include<stdio.h>
int main(){
int a[3] = {1,2},*p = a; #这是我们常见做法,将a的首地址传给指针,然后由指针自身加减,来遍历整个列表
for(;p<a+2;p++){
	printf("%d",*p);
}
}

#既然 列表 a 的首地址就是 a ,那为什么要多此一举呢,能直接遍历这个首地址吗?
//现在我们来操作看看
#include<stdio.h>
int main(){
int a[2] = {1,2};
for( ;*a != 0;a++){
	printf("%d",*a);
}
}
```

我们发现这样运行是错误的,这说明,虽然列表的 **地址** 是 **列表元素** 的首地址故而,在操作上可以用列表 `a` 代替存放列表的地址 `*p` ,但列表自身不能通过自增自减来实现,列表内部元素的 **遍历**

这让我们真切地产生了疑惑,那 **列表** 和 指针究竟有什么关系呢 ?

现在我就不卖弄这个关子了, 列表实质上就是指针的集合,用大白话理解就是,列表就是指针的群体,故我们可以得出以下重要推论:

`(*p)[]` 完全等价于 ` a[]`



我们再回过头想想,我们之前设想的 **即使这个群体的地址就是这个列表元素的首地址 , 但我们还是不能直接把这个群体的地址进行相加减,以得到这个群里里每个元素的地址,如果这样成功的话就太荒唐了** 

我们而只能将这个 **群体** 的地址 (实际上我们给的是这个群体里第一个元素的地址) , 赋给`*p`,让  ` *p` 进行加减来得到

那真的不能利用 ` a` 的地址来得到全体元素变量了吗,我们来试试



```c
#include<stdio.h>

int main(){
int a[2] = {1,2},i; #这是我们常见做法,将a的首地址传给指针,然后由指针自身加减,来遍历整个列表
for(i=0;i<2;i++){
	printf("%d",*(a+i));
}
}

```

以上代码就是我们经常学到的,这段代码的威力就是,没有引入 ` *p` ,而是让列表地址来代表第一个元素的首地址,但又不对这个地址本身进行加减遍历,而是通过计数变量 `i` ,来实现整体 `*(a+i)` 的递增,它就相当于:

```c
#include<stdio.h>

int main(){
int a[2] = {1,2},*p=a; #这是我们常见做法,将a的首地址传给指针,然后由指针自身加减,来遍历整个列表
for(i=0;i<2;i++){
	printf("%d",*(p+i));
}
}

```

*注意:将本代码与本文开篇有关 `p++` 的代码仔细对比*

那为什么我们能直接通过列表中的某个元素地址加减,就能得到其他其他元素地址了呢?这就牵涉到我们下一个话题:



### 列表元素在内存里的排列

>    我们要知道内存已经是计算机底层构件,已经不会再有类似于 **列表** 这样抽象容器将里面的地址包含



>   当我们开始创建列表时,系统将列表中的每一个元素存放在内存里的连续单元中

这也就解释了,为什么列表中第一个元素的地址是这个这个列表的地址,因为系统只用知道这一个首地址,能通过不断调出后续连续单元里储存的地址,来遍历这个列表

这也就解释了,我们可以利用 `(*p)[N]` 来代表一个二元列表 `a[N][M]`



### 总结

我们将我们学到的总结一下:

-   `*p` 等价于 `p[0]`

-   `(*p)[N]`  等价于 ` a[N]`

-   `(*p)[N]` 可以代表 `a[N][M]`

    